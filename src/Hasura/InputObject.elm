-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module Hasura.InputObject exposing (..)

import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Hasura.Enum.Order_by
import Hasura.Enum.Todos_constraint
import Hasura.Enum.Todos_update_column
import Hasura.Enum.Users_constraint
import Hasura.Enum.Users_update_column
import Hasura.Interface
import Hasura.Object
import Hasura.Scalar
import Hasura.ScalarCodecs
import Hasura.Union
import Json.Decode as Decode


buildBoolean_comparison_exp :
    (Boolean_comparison_expOptionalFields -> Boolean_comparison_expOptionalFields)
    -> Boolean_comparison_exp
buildBoolean_comparison_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals____.eq_, gt_ = optionals____.gt_, gte_ = optionals____.gte_, in_ = optionals____.in_, is_null_ = optionals____.is_null_, lt_ = optionals____.lt_, lte_ = optionals____.lte_, neq_ = optionals____.neq_, nin_ = optionals____.nin_ }


type alias Boolean_comparison_expOptionalFields =
    { eq_ : OptionalArgument Bool
    , gt_ : OptionalArgument Bool
    , gte_ : OptionalArgument Bool
    , in_ : OptionalArgument (List Bool)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Bool
    , lte_ : OptionalArgument Bool
    , neq_ : OptionalArgument Bool
    , nin_ : OptionalArgument (List Bool)
    }


{-| Type for the Boolean\_comparison\_exp input object.
-}
type alias Boolean_comparison_exp =
    { eq_ : OptionalArgument Bool
    , gt_ : OptionalArgument Bool
    , gte_ : OptionalArgument Bool
    , in_ : OptionalArgument (List Bool)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Bool
    , lte_ : OptionalArgument Bool
    , neq_ : OptionalArgument Bool
    , nin_ : OptionalArgument (List Bool)
    }


{-| Encode a Boolean\_comparison\_exp into a value that can be used as an argument.
-}
encodeBoolean_comparison_exp : Boolean_comparison_exp -> Value
encodeBoolean_comparison_exp input____ =
    Encode.maybeObject
        [ ( "_eq", Encode.bool |> Encode.optional input____.eq_ ), ( "_gt", Encode.bool |> Encode.optional input____.gt_ ), ( "_gte", Encode.bool |> Encode.optional input____.gte_ ), ( "_in", (Encode.bool |> Encode.list) |> Encode.optional input____.in_ ), ( "_is_null", Encode.bool |> Encode.optional input____.is_null_ ), ( "_lt", Encode.bool |> Encode.optional input____.lt_ ), ( "_lte", Encode.bool |> Encode.optional input____.lte_ ), ( "_neq", Encode.bool |> Encode.optional input____.neq_ ), ( "_nin", (Encode.bool |> Encode.list) |> Encode.optional input____.nin_ ) ]


buildInt_comparison_exp :
    (Int_comparison_expOptionalFields -> Int_comparison_expOptionalFields)
    -> Int_comparison_exp
buildInt_comparison_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals____.eq_, gt_ = optionals____.gt_, gte_ = optionals____.gte_, in_ = optionals____.in_, is_null_ = optionals____.is_null_, lt_ = optionals____.lt_, lte_ = optionals____.lte_, neq_ = optionals____.neq_, nin_ = optionals____.nin_ }


type alias Int_comparison_expOptionalFields =
    { eq_ : OptionalArgument Int
    , gt_ : OptionalArgument Int
    , gte_ : OptionalArgument Int
    , in_ : OptionalArgument (List Int)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Int
    , lte_ : OptionalArgument Int
    , neq_ : OptionalArgument Int
    , nin_ : OptionalArgument (List Int)
    }


{-| Type for the Int\_comparison\_exp input object.
-}
type alias Int_comparison_exp =
    { eq_ : OptionalArgument Int
    , gt_ : OptionalArgument Int
    , gte_ : OptionalArgument Int
    , in_ : OptionalArgument (List Int)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Int
    , lte_ : OptionalArgument Int
    , neq_ : OptionalArgument Int
    , nin_ : OptionalArgument (List Int)
    }


{-| Encode a Int\_comparison\_exp into a value that can be used as an argument.
-}
encodeInt_comparison_exp : Int_comparison_exp -> Value
encodeInt_comparison_exp input____ =
    Encode.maybeObject
        [ ( "_eq", Encode.int |> Encode.optional input____.eq_ ), ( "_gt", Encode.int |> Encode.optional input____.gt_ ), ( "_gte", Encode.int |> Encode.optional input____.gte_ ), ( "_in", (Encode.int |> Encode.list) |> Encode.optional input____.in_ ), ( "_is_null", Encode.bool |> Encode.optional input____.is_null_ ), ( "_lt", Encode.int |> Encode.optional input____.lt_ ), ( "_lte", Encode.int |> Encode.optional input____.lte_ ), ( "_neq", Encode.int |> Encode.optional input____.neq_ ), ( "_nin", (Encode.int |> Encode.list) |> Encode.optional input____.nin_ ) ]


buildOnline_users_bool_exp :
    (Online_users_bool_expOptionalFields -> Online_users_bool_expOptionalFields)
    -> Online_users_bool_exp
buildOnline_users_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, id = Absent, last_seen = Absent, user = Absent }
    in
    Online_users_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, id = optionals____.id, last_seen = optionals____.last_seen, user = optionals____.user }


type alias Online_users_bool_expOptionalFields =
    { and_ : OptionalArgument (List (Maybe Online_users_bool_exp))
    , not_ : OptionalArgument Online_users_bool_exp
    , or_ : OptionalArgument (List (Maybe Online_users_bool_exp))
    , id : OptionalArgument String_comparison_exp
    , last_seen : OptionalArgument Timestamptz_comparison_exp
    , user : OptionalArgument Users_bool_exp
    }


{-| Type alias for the `Online_users_bool_exp` attributes. Note that this type
needs to use the `Online_users_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Online_users_bool_expRaw =
    { and_ : OptionalArgument (List (Maybe Online_users_bool_exp))
    , not_ : OptionalArgument Online_users_bool_exp
    , or_ : OptionalArgument (List (Maybe Online_users_bool_exp))
    , id : OptionalArgument String_comparison_exp
    , last_seen : OptionalArgument Timestamptz_comparison_exp
    , user : OptionalArgument Users_bool_exp
    }


{-| Type for the Online\_users\_bool\_exp input object.
-}
type Online_users_bool_exp
    = Online_users_bool_exp Online_users_bool_expRaw


{-| Encode a Online\_users\_bool\_exp into a value that can be used as an argument.
-}
encodeOnline_users_bool_exp : Online_users_bool_exp -> Value
encodeOnline_users_bool_exp (Online_users_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeOnline_users_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeOnline_users_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeOnline_users_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input____.or_ ), ( "id", encodeString_comparison_exp |> Encode.optional input____.id ), ( "last_seen", encodeTimestamptz_comparison_exp |> Encode.optional input____.last_seen ), ( "user", encodeUsers_bool_exp |> Encode.optional input____.user ) ]


buildOnline_users_order_by :
    (Online_users_order_byOptionalFields -> Online_users_order_byOptionalFields)
    -> Online_users_order_by
buildOnline_users_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, last_seen = Absent, user = Absent }
    in
    { id = optionals____.id, last_seen = optionals____.last_seen, user = optionals____.user }


type alias Online_users_order_byOptionalFields =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , last_seen : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user : OptionalArgument Users_order_by
    }


{-| Type for the Online\_users\_order\_by input object.
-}
type alias Online_users_order_by =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , last_seen : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user : OptionalArgument Users_order_by
    }


{-| Encode a Online\_users\_order\_by into a value that can be used as an argument.
-}
encodeOnline_users_order_by : Online_users_order_by -> Value
encodeOnline_users_order_by input____ =
    Encode.maybeObject
        [ ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.id ), ( "last_seen", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.last_seen ), ( "user", encodeUsers_order_by |> Encode.optional input____.user ) ]


buildString_comparison_exp :
    (String_comparison_expOptionalFields -> String_comparison_expOptionalFields)
    -> String_comparison_exp
buildString_comparison_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, ilike_ = Absent, in_ = Absent, is_null_ = Absent, like_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nilike_ = Absent, nin_ = Absent, nlike_ = Absent, nsimilar_ = Absent, similar_ = Absent }
    in
    { eq_ = optionals____.eq_, gt_ = optionals____.gt_, gte_ = optionals____.gte_, ilike_ = optionals____.ilike_, in_ = optionals____.in_, is_null_ = optionals____.is_null_, like_ = optionals____.like_, lt_ = optionals____.lt_, lte_ = optionals____.lte_, neq_ = optionals____.neq_, nilike_ = optionals____.nilike_, nin_ = optionals____.nin_, nlike_ = optionals____.nlike_, nsimilar_ = optionals____.nsimilar_, similar_ = optionals____.similar_ }


type alias String_comparison_expOptionalFields =
    { eq_ : OptionalArgument String
    , gt_ : OptionalArgument String
    , gte_ : OptionalArgument String
    , ilike_ : OptionalArgument String
    , in_ : OptionalArgument (List String)
    , is_null_ : OptionalArgument Bool
    , like_ : OptionalArgument String
    , lt_ : OptionalArgument String
    , lte_ : OptionalArgument String
    , neq_ : OptionalArgument String
    , nilike_ : OptionalArgument String
    , nin_ : OptionalArgument (List String)
    , nlike_ : OptionalArgument String
    , nsimilar_ : OptionalArgument String
    , similar_ : OptionalArgument String
    }


{-| Type for the String\_comparison\_exp input object.
-}
type alias String_comparison_exp =
    { eq_ : OptionalArgument String
    , gt_ : OptionalArgument String
    , gte_ : OptionalArgument String
    , ilike_ : OptionalArgument String
    , in_ : OptionalArgument (List String)
    , is_null_ : OptionalArgument Bool
    , like_ : OptionalArgument String
    , lt_ : OptionalArgument String
    , lte_ : OptionalArgument String
    , neq_ : OptionalArgument String
    , nilike_ : OptionalArgument String
    , nin_ : OptionalArgument (List String)
    , nlike_ : OptionalArgument String
    , nsimilar_ : OptionalArgument String
    , similar_ : OptionalArgument String
    }


{-| Encode a String\_comparison\_exp into a value that can be used as an argument.
-}
encodeString_comparison_exp : String_comparison_exp -> Value
encodeString_comparison_exp input____ =
    Encode.maybeObject
        [ ( "_eq", Encode.string |> Encode.optional input____.eq_ ), ( "_gt", Encode.string |> Encode.optional input____.gt_ ), ( "_gte", Encode.string |> Encode.optional input____.gte_ ), ( "_ilike", Encode.string |> Encode.optional input____.ilike_ ), ( "_in", (Encode.string |> Encode.list) |> Encode.optional input____.in_ ), ( "_is_null", Encode.bool |> Encode.optional input____.is_null_ ), ( "_like", Encode.string |> Encode.optional input____.like_ ), ( "_lt", Encode.string |> Encode.optional input____.lt_ ), ( "_lte", Encode.string |> Encode.optional input____.lte_ ), ( "_neq", Encode.string |> Encode.optional input____.neq_ ), ( "_nilike", Encode.string |> Encode.optional input____.nilike_ ), ( "_nin", (Encode.string |> Encode.list) |> Encode.optional input____.nin_ ), ( "_nlike", Encode.string |> Encode.optional input____.nlike_ ), ( "_nsimilar", Encode.string |> Encode.optional input____.nsimilar_ ), ( "_similar", Encode.string |> Encode.optional input____.similar_ ) ]


buildTimestamptz_comparison_exp :
    (Timestamptz_comparison_expOptionalFields -> Timestamptz_comparison_expOptionalFields)
    -> Timestamptz_comparison_exp
buildTimestamptz_comparison_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals____.eq_, gt_ = optionals____.gt_, gte_ = optionals____.gte_, in_ = optionals____.in_, is_null_ = optionals____.is_null_, lt_ = optionals____.lt_, lte_ = optionals____.lte_, neq_ = optionals____.neq_, nin_ = optionals____.nin_ }


type alias Timestamptz_comparison_expOptionalFields =
    { eq_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , gt_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , gte_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , in_ : OptionalArgument (List Hasura.ScalarCodecs.Timestamptz)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , lte_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , neq_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , nin_ : OptionalArgument (List Hasura.ScalarCodecs.Timestamptz)
    }


{-| Type for the Timestamptz\_comparison\_exp input object.
-}
type alias Timestamptz_comparison_exp =
    { eq_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , gt_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , gte_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , in_ : OptionalArgument (List Hasura.ScalarCodecs.Timestamptz)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , lte_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , neq_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , nin_ : OptionalArgument (List Hasura.ScalarCodecs.Timestamptz)
    }


{-| Encode a Timestamptz\_comparison\_exp into a value that can be used as an argument.
-}
encodeTimestamptz_comparison_exp : Timestamptz_comparison_exp -> Value
encodeTimestamptz_comparison_exp input____ =
    Encode.maybeObject
        [ ( "_eq", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.eq_ ), ( "_gt", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.gt_ ), ( "_gte", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.gte_ ), ( "_in", ((Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.list) |> Encode.optional input____.in_ ), ( "_is_null", Encode.bool |> Encode.optional input____.is_null_ ), ( "_lt", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.lt_ ), ( "_lte", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.lte_ ), ( "_neq", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.neq_ ), ( "_nin", ((Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.list) |> Encode.optional input____.nin_ ) ]


buildTodos_arr_rel_insert_input :
    Todos_arr_rel_insert_inputRequiredFields
    -> (Todos_arr_rel_insert_inputOptionalFields -> Todos_arr_rel_insert_inputOptionalFields)
    -> Todos_arr_rel_insert_input
buildTodos_arr_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    Todos_arr_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias Todos_arr_rel_insert_inputRequiredFields =
    { data : List Todos_insert_input }


type alias Todos_arr_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Todos_on_conflict }


{-| Type alias for the `Todos_arr_rel_insert_input` attributes. Note that this type
needs to use the `Todos_arr_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Todos_arr_rel_insert_inputRaw =
    { data : List Todos_insert_input
    , on_conflict : OptionalArgument Todos_on_conflict
    }


{-| Type for the Todos\_arr\_rel\_insert\_input input object.
-}
type Todos_arr_rel_insert_input
    = Todos_arr_rel_insert_input Todos_arr_rel_insert_inputRaw


{-| Encode a Todos\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeTodos_arr_rel_insert_input : Todos_arr_rel_insert_input -> Value
encodeTodos_arr_rel_insert_input (Todos_arr_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", (encodeTodos_insert_input |> Encode.list) input____.data |> Just ), ( "on_conflict", encodeTodos_on_conflict |> Encode.optional input____.on_conflict ) ]


buildTodos_bool_exp :
    (Todos_bool_expOptionalFields -> Todos_bool_expOptionalFields)
    -> Todos_bool_exp
buildTodos_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, created_at = Absent, id = Absent, is_completed = Absent, is_public = Absent, title = Absent, user = Absent, user_id = Absent }
    in
    Todos_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, created_at = optionals____.created_at, id = optionals____.id, is_completed = optionals____.is_completed, is_public = optionals____.is_public, title = optionals____.title, user = optionals____.user, user_id = optionals____.user_id }


type alias Todos_bool_expOptionalFields =
    { and_ : OptionalArgument (List (Maybe Todos_bool_exp))
    , not_ : OptionalArgument Todos_bool_exp
    , or_ : OptionalArgument (List (Maybe Todos_bool_exp))
    , created_at : OptionalArgument Timestamptz_comparison_exp
    , id : OptionalArgument Int_comparison_exp
    , is_completed : OptionalArgument Boolean_comparison_exp
    , is_public : OptionalArgument Boolean_comparison_exp
    , title : OptionalArgument String_comparison_exp
    , user : OptionalArgument Users_bool_exp
    , user_id : OptionalArgument String_comparison_exp
    }


{-| Type alias for the `Todos_bool_exp` attributes. Note that this type
needs to use the `Todos_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Todos_bool_expRaw =
    { and_ : OptionalArgument (List (Maybe Todos_bool_exp))
    , not_ : OptionalArgument Todos_bool_exp
    , or_ : OptionalArgument (List (Maybe Todos_bool_exp))
    , created_at : OptionalArgument Timestamptz_comparison_exp
    , id : OptionalArgument Int_comparison_exp
    , is_completed : OptionalArgument Boolean_comparison_exp
    , is_public : OptionalArgument Boolean_comparison_exp
    , title : OptionalArgument String_comparison_exp
    , user : OptionalArgument Users_bool_exp
    , user_id : OptionalArgument String_comparison_exp
    }


{-| Type for the Todos\_bool\_exp input object.
-}
type Todos_bool_exp
    = Todos_bool_exp Todos_bool_expRaw


{-| Encode a Todos\_bool\_exp into a value that can be used as an argument.
-}
encodeTodos_bool_exp : Todos_bool_exp -> Value
encodeTodos_bool_exp (Todos_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeTodos_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeTodos_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeTodos_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input____.or_ ), ( "created_at", encodeTimestamptz_comparison_exp |> Encode.optional input____.created_at ), ( "id", encodeInt_comparison_exp |> Encode.optional input____.id ), ( "is_completed", encodeBoolean_comparison_exp |> Encode.optional input____.is_completed ), ( "is_public", encodeBoolean_comparison_exp |> Encode.optional input____.is_public ), ( "title", encodeString_comparison_exp |> Encode.optional input____.title ), ( "user", encodeUsers_bool_exp |> Encode.optional input____.user ), ( "user_id", encodeString_comparison_exp |> Encode.optional input____.user_id ) ]


buildTodos_insert_input :
    (Todos_insert_inputOptionalFields -> Todos_insert_inputOptionalFields)
    -> Todos_insert_input
buildTodos_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { is_public = Absent, title = Absent }
    in
    { is_public = optionals____.is_public, title = optionals____.title }


type alias Todos_insert_inputOptionalFields =
    { is_public : OptionalArgument Bool
    , title : OptionalArgument String
    }


{-| Type for the Todos\_insert\_input input object.
-}
type alias Todos_insert_input =
    { is_public : OptionalArgument Bool
    , title : OptionalArgument String
    }


{-| Encode a Todos\_insert\_input into a value that can be used as an argument.
-}
encodeTodos_insert_input : Todos_insert_input -> Value
encodeTodos_insert_input input____ =
    Encode.maybeObject
        [ ( "is_public", Encode.bool |> Encode.optional input____.is_public ), ( "title", Encode.string |> Encode.optional input____.title ) ]


buildTodos_obj_rel_insert_input :
    Todos_obj_rel_insert_inputRequiredFields
    -> (Todos_obj_rel_insert_inputOptionalFields -> Todos_obj_rel_insert_inputOptionalFields)
    -> Todos_obj_rel_insert_input
buildTodos_obj_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    Todos_obj_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias Todos_obj_rel_insert_inputRequiredFields =
    { data : Todos_insert_input }


type alias Todos_obj_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Todos_on_conflict }


{-| Type alias for the `Todos_obj_rel_insert_input` attributes. Note that this type
needs to use the `Todos_obj_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Todos_obj_rel_insert_inputRaw =
    { data : Todos_insert_input
    , on_conflict : OptionalArgument Todos_on_conflict
    }


{-| Type for the Todos\_obj\_rel\_insert\_input input object.
-}
type Todos_obj_rel_insert_input
    = Todos_obj_rel_insert_input Todos_obj_rel_insert_inputRaw


{-| Encode a Todos\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeTodos_obj_rel_insert_input : Todos_obj_rel_insert_input -> Value
encodeTodos_obj_rel_insert_input (Todos_obj_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", encodeTodos_insert_input input____.data |> Just ), ( "on_conflict", encodeTodos_on_conflict |> Encode.optional input____.on_conflict ) ]


buildTodos_on_conflict :
    Todos_on_conflictRequiredFields
    -> (Todos_on_conflictOptionalFields -> Todos_on_conflictOptionalFields)
    -> Todos_on_conflict
buildTodos_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    Todos_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias Todos_on_conflictRequiredFields =
    { constraint : Hasura.Enum.Todos_constraint.Todos_constraint
    , update_columns : List Hasura.Enum.Todos_update_column.Todos_update_column
    }


type alias Todos_on_conflictOptionalFields =
    { where_ : OptionalArgument Todos_bool_exp }


{-| Type alias for the `Todos_on_conflict` attributes. Note that this type
needs to use the `Todos_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Todos_on_conflictRaw =
    { constraint : Hasura.Enum.Todos_constraint.Todos_constraint
    , update_columns : List Hasura.Enum.Todos_update_column.Todos_update_column
    , where_ : OptionalArgument Todos_bool_exp
    }


{-| Type for the Todos\_on\_conflict input object.
-}
type Todos_on_conflict
    = Todos_on_conflict Todos_on_conflictRaw


{-| Encode a Todos\_on\_conflict into a value that can be used as an argument.
-}
encodeTodos_on_conflict : Todos_on_conflict -> Value
encodeTodos_on_conflict (Todos_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum Hasura.Enum.Todos_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum Hasura.Enum.Todos_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeTodos_bool_exp |> Encode.optional input____.where_ ) ]


buildTodos_order_by :
    (Todos_order_byOptionalFields -> Todos_order_byOptionalFields)
    -> Todos_order_by
buildTodos_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { created_at = Absent, id = Absent, is_completed = Absent, is_public = Absent, title = Absent, user = Absent, user_id = Absent }
    in
    { created_at = optionals____.created_at, id = optionals____.id, is_completed = optionals____.is_completed, is_public = optionals____.is_public, title = optionals____.title, user = optionals____.user, user_id = optionals____.user_id }


type alias Todos_order_byOptionalFields =
    { created_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , is_completed : OptionalArgument Hasura.Enum.Order_by.Order_by
    , is_public : OptionalArgument Hasura.Enum.Order_by.Order_by
    , title : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user : OptionalArgument Users_order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the Todos\_order\_by input object.
-}
type alias Todos_order_by =
    { created_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , is_completed : OptionalArgument Hasura.Enum.Order_by.Order_by
    , is_public : OptionalArgument Hasura.Enum.Order_by.Order_by
    , title : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user : OptionalArgument Users_order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Encode a Todos\_order\_by into a value that can be used as an argument.
-}
encodeTodos_order_by : Todos_order_by -> Value
encodeTodos_order_by input____ =
    Encode.maybeObject
        [ ( "created_at", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.created_at ), ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.id ), ( "is_completed", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.is_completed ), ( "is_public", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.is_public ), ( "title", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.title ), ( "user", encodeUsers_order_by |> Encode.optional input____.user ), ( "user_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.user_id ) ]


buildTodos_pk_columns_input :
    Todos_pk_columns_inputRequiredFields
    -> Todos_pk_columns_input
buildTodos_pk_columns_input required____ =
    { id = required____.id }


type alias Todos_pk_columns_inputRequiredFields =
    { id : Int }


{-| Type for the Todos\_pk\_columns\_input input object.
-}
type alias Todos_pk_columns_input =
    { id : Int }


{-| Encode a Todos\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeTodos_pk_columns_input : Todos_pk_columns_input -> Value
encodeTodos_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "id", Encode.int input____.id |> Just ) ]


buildTodos_set_input :
    (Todos_set_inputOptionalFields -> Todos_set_inputOptionalFields)
    -> Todos_set_input
buildTodos_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { is_completed = Absent, title = Absent }
    in
    { is_completed = optionals____.is_completed, title = optionals____.title }


type alias Todos_set_inputOptionalFields =
    { is_completed : OptionalArgument Bool
    , title : OptionalArgument String
    }


{-| Type for the Todos\_set\_input input object.
-}
type alias Todos_set_input =
    { is_completed : OptionalArgument Bool
    , title : OptionalArgument String
    }


{-| Encode a Todos\_set\_input into a value that can be used as an argument.
-}
encodeTodos_set_input : Todos_set_input -> Value
encodeTodos_set_input input____ =
    Encode.maybeObject
        [ ( "is_completed", Encode.bool |> Encode.optional input____.is_completed ), ( "title", Encode.string |> Encode.optional input____.title ) ]


buildUsers_bool_exp :
    (Users_bool_expOptionalFields -> Users_bool_expOptionalFields)
    -> Users_bool_exp
buildUsers_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, id = Absent, name = Absent, todos = Absent }
    in
    Users_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, id = optionals____.id, name = optionals____.name, todos = optionals____.todos }


type alias Users_bool_expOptionalFields =
    { and_ : OptionalArgument (List (Maybe Users_bool_exp))
    , not_ : OptionalArgument Users_bool_exp
    , or_ : OptionalArgument (List (Maybe Users_bool_exp))
    , id : OptionalArgument String_comparison_exp
    , name : OptionalArgument String_comparison_exp
    , todos : OptionalArgument Todos_bool_exp
    }


{-| Type alias for the `Users_bool_exp` attributes. Note that this type
needs to use the `Users_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Users_bool_expRaw =
    { and_ : OptionalArgument (List (Maybe Users_bool_exp))
    , not_ : OptionalArgument Users_bool_exp
    , or_ : OptionalArgument (List (Maybe Users_bool_exp))
    , id : OptionalArgument String_comparison_exp
    , name : OptionalArgument String_comparison_exp
    , todos : OptionalArgument Todos_bool_exp
    }


{-| Type for the Users\_bool\_exp input object.
-}
type Users_bool_exp
    = Users_bool_exp Users_bool_expRaw


{-| Encode a Users\_bool\_exp into a value that can be used as an argument.
-}
encodeUsers_bool_exp : Users_bool_exp -> Value
encodeUsers_bool_exp (Users_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeUsers_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeUsers_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeUsers_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input____.or_ ), ( "id", encodeString_comparison_exp |> Encode.optional input____.id ), ( "name", encodeString_comparison_exp |> Encode.optional input____.name ), ( "todos", encodeTodos_bool_exp |> Encode.optional input____.todos ) ]


buildUsers_on_conflict :
    Users_on_conflictRequiredFields
    -> (Users_on_conflictOptionalFields -> Users_on_conflictOptionalFields)
    -> Users_on_conflict
buildUsers_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    Users_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias Users_on_conflictRequiredFields =
    { constraint : Hasura.Enum.Users_constraint.Users_constraint
    , update_columns : List Hasura.Enum.Users_update_column.Users_update_column
    }


type alias Users_on_conflictOptionalFields =
    { where_ : OptionalArgument Users_bool_exp }


{-| Type alias for the `Users_on_conflict` attributes. Note that this type
needs to use the `Users_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Users_on_conflictRaw =
    { constraint : Hasura.Enum.Users_constraint.Users_constraint
    , update_columns : List Hasura.Enum.Users_update_column.Users_update_column
    , where_ : OptionalArgument Users_bool_exp
    }


{-| Type for the Users\_on\_conflict input object.
-}
type Users_on_conflict
    = Users_on_conflict Users_on_conflictRaw


{-| Encode a Users\_on\_conflict into a value that can be used as an argument.
-}
encodeUsers_on_conflict : Users_on_conflict -> Value
encodeUsers_on_conflict (Users_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum Hasura.Enum.Users_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum Hasura.Enum.Users_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeUsers_bool_exp |> Encode.optional input____.where_ ) ]


buildUsers_order_by :
    (Users_order_byOptionalFields -> Users_order_byOptionalFields)
    -> Users_order_by
buildUsers_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, name = Absent }
    in
    { id = optionals____.id, name = optionals____.name }


type alias Users_order_byOptionalFields =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , name : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the Users\_order\_by input object.
-}
type alias Users_order_by =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , name : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Encode a Users\_order\_by into a value that can be used as an argument.
-}
encodeUsers_order_by : Users_order_by -> Value
encodeUsers_order_by input____ =
    Encode.maybeObject
        [ ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.id ), ( "name", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.name ) ]


buildUsers_pk_columns_input :
    Users_pk_columns_inputRequiredFields
    -> Users_pk_columns_input
buildUsers_pk_columns_input required____ =
    { id = required____.id }


type alias Users_pk_columns_inputRequiredFields =
    { id : String }


{-| Type for the Users\_pk\_columns\_input input object.
-}
type alias Users_pk_columns_input =
    { id : String }


{-| Encode a Users\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeUsers_pk_columns_input : Users_pk_columns_input -> Value
encodeUsers_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "id", Encode.string input____.id |> Just ) ]


buildUsers_set_input :
    (Users_set_inputOptionalFields -> Users_set_inputOptionalFields)
    -> Users_set_input
buildUsers_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { last_seen = Absent }
    in
    { last_seen = optionals____.last_seen }


type alias Users_set_inputOptionalFields =
    { last_seen : OptionalArgument Hasura.ScalarCodecs.Timestamptz }


{-| Type for the Users\_set\_input input object.
-}
type alias Users_set_input =
    { last_seen : OptionalArgument Hasura.ScalarCodecs.Timestamptz }


{-| Encode a Users\_set\_input into a value that can be used as an argument.
-}
encodeUsers_set_input : Users_set_input -> Value
encodeUsers_set_input input____ =
    Encode.maybeObject
        [ ( "last_seen", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.last_seen ) ]
